# 깃 실습 시현

![오이카와 토오루](./contents/오이카와토루.png) |  ![오이카와 토오루](./contents/스가와라코우시.png) | ![오이카와 토오루](./contents/히나타쇼요.png) 
:-------------------------:|:-------------------------:|:-------------------------:
**오이카와 토오루** | **스가와라 코우시** | **히나타 쇼요**
Administrator | Collaborator | Contributor
권한 O | 권한 O | 권한 X

## 배경 설명
여기 오이카와와 스가와라라는 고등학교 3학년의 두 친구가 있습니다. 두 친구는 19년 최고 성적을 낸 배구 선수들을 분석해보려 해요. 오이카와가 제안한 프로젝트이기 때문에 작업 중간중간 스가가 도움을 주는 방식으로 진행하기로 했어요.

## 작업 시나리오

### 오이카와 1
오이카와는 자신이 준비해둔 데이터인 19년 배구 선수 데이터와 분석 초안 파일을 가지고 있어요. 스가와의 협업을 위해서는 해당 작업 폴더에 깃을 설치하고 온라인 저장소에 올려줘야겠죠?

1. 로컬 폴더에 깃 설치하기
    ```shell
    git init
    ```
    오이카와의 로컬 폴더(Working Directory)에는 csv 파일과 ipynb 파일이 있어요. 해당 파일들의 변화를 추적해줄 git을 설치해봅시다. 터미널로 해당 로컬 폴더 위치로 이동 후, 명령어 git init을 쳐주세요.


2. 깃헙 레포지토리 만들기


    스가와라와의 협업을 위해 클라우드 저장소가 필요하겠죠? 깃헙에 온라인 프로젝트 저장소인 레포지토리를 만들어봅시다.


3. 로컬 폴더와 레포지토리 연결하기
    ```shell
    git remote add origin 레포지토리_깃_링크
    ```
    로컬 폴더의 변화들을 모아 온라인 레포지토리에 커밋하기 위해 로컬 폴더와 레포지토리를 연결시켜줘야겠죠?


4. 커밋에 포함할 변화 고르기
    ```shell
    git add .
    ```
    커밋은 ‘의미있는 변화의 덩어리’라고 했어요. 커밋하기 전, 덩어리에 포함시킬 변화를 골라 스테이지 공간에 올려두는 게 필수라고 했죠? git add를 통해 변화들을 골라봅시다. 오이카와는 csv, ipynb 파일 전부 올리려 하니, 명령어 뒤에 . 을 찍어서 모두 선택해줍시다.


5. 고른 변화들을 덩어리로 묶어주기
    ```shell
    git commit -m "커밋 메시지"
    ```
    git add를 통해 스테이지 공간에 있는 변화들을 덩어리로 묶어줘야 해요. 이 덩어리들이 레포지토리에 입력이 되면, 이제 이 커밋 자체가 새로운 버전이 됩니다. -m 뒤 따옴표에는 커밋에 대한 짧은 설명을 적어주면 돼요.


6. 커밋을 레포지토리에 적용하기
    ```shell
    git push origin master
    ```
    커밋을 레포지토리에 적용하는 일반적인 방법이에요. 커밋 적용, 즉 푸쉬 전후로 버전이 달라져요.


7. 작업 권한 부여하기

    자, 이제 작업 폴더에 있는 모든 파일을 온라인 저장소인 레포지토리로 옮겼어요. 이제 스가와라에게 작업을 부탁해야 하는데, 지금 상태로는 스가와라가 레포지토리에 작업 권한이 없어요.
    레포지토리 페이지에서 Settings > Manage Access > Invite a Collaborator를 통해 스가와라에게 작업 권한을 부여해줄게요.

### 스가와라 1
오이카와의 작업물을 받아와서 작업을 해야하는 스가와라, 어떻게 프로젝트를 진행할까요?

1. 공개된 레포지토리 로컬 폴더에 받기
    ```shell
    git clone 레포지토리_깃_링크 .
    ```
    오이카와의 레포지토리를 로컬 폴더에 다운받아줄 거에요! 주의할 점은, 특정 폴더 내에서 clone할 경우 뒤에 . 을 붙여줘야 한다는 점! 스가와라는 만들어둔 폴더 내에 오이카와의 레포지토리를 클론해오려고 레포지토리 깃 링크 뒤에 . 을 붙였어요.


2. 작업하기
    ```python
    setter_players=best_players[best_players['Position']=='Setter']
    setter_players
    ```
    스가와라는 세터 포지션이기 때문에 세터 선수들만 따로 빼내어 데이터프레임을 만들었어요.


3. 커밋에 포함할 변화 고르기
    ```shell
    git add .
    ```
    . 을 통해 전체 선택을 해줘도 변형이 이뤄진 건 ipynb 파일 뿐이기 때문에 해당 파일만 stage로 이동해요.


4. 고른 변화들을 덩어리로 묶어주기
    ```shell
    git commit -m "커밋 메시지"
    ```
    세터 데이터프레임을 만든 내용의 파일 변화를 하나의 버전, 즉 커밋으로 만들어줘요.

5. 커밋을 레포지토리에 적용하기
    ```shell
    git push origin master
    ```
    push 명령어를 통해 커밋 내용을 레포지토리에 적용시켜주면, 완성!

### 오이카와 2
앗 스가와라가 작업을 시작했네요! 레포지토리에 적용된 스가와라의 커밋을 로컬 폴더에도 적용시켜줄게요.

1. 레포지토리의 커밋 로컬 폴더에 적용하기
    ```shell
    git pull origin master
    ```
    스가와라의 커밋을 로컬 폴더에 적용시켜줄 거에요. 이를 위해서는 git pull이라는 명령어를 사용해요. 적용 완료! 이제 오이카와의 컴퓨터 작업 폴더에 있는 ipynb 파일에서도 세터 선수만 뽑은 데이터프레임을 볼 수 있어요.

### 히나타 1
순조롭게 진행이 되는 것 같았는데 1학년 히나타가 들어왔어요. 히나타는 아직 배운 게 적고 실수가 많아 오이카와나 스가와라처럼 직접 푸쉬를 하는 건 위험할 것 같아요. 위험성을 줄이기 위해 히나타는 포크를 통해 자신의 깃헙 계정에 복사본 레포지토리를 만들고, 복사본 레포지토리에 커밋 및 푸쉬를 한 후 해당 변화를 오리지널 레포지토리에 적용하기로 했어요.

1. 클라우드 서비스에 레포지토리 복사본 만들기


    오이카와, 스가와라 선배들에 비해 경험이 부족해 실수할 가능성이 많은 히나타! 위험을 줄이기 위해 복사본을 만들어 작업할 거에요. 레포지토리 복사본을 만드는 방법은 복사를 원하는 레포지토리 페이지에 들어가 우측 상단에 있는 fork 버튼을 누른느 거에요.


2. 공개된 레포지토리 로컬 폴더에 받기
    ```shell
    git clone 레포지토리_깃_링크
    ```
    히나타는 원본이 아닌 자신의 깃헙에 복사된 레포지토리를 클론해줄 거에요. 스가와라랑은 달리 폴더를 미리 만들어두지 않아서 . 없이 바로 clone 해줄게요.


3. 작업하기
    ```python
    best_players.sort_values(by='Ranking All',ascending=True)
    ```
    히나타는 높은 점수의 선수가 롤 모델이라서, 19년도 베스트 플레이어로 뽑힌 선수들의 누적 랭킹으로 줄을 세워봤어요.


4. 커밋에 포함할 변화 고르기
    ```shell
    git add 원하는_파일_경로
    ```
    사실 . 을 통해 전부 다 선택해도 되지만, 혹시 몰라 실수할까 두려운 히나타는 자신이 건드린 ipynb 파일 하나만 선택해서 스테이지로 넘겨줬어요.


5. 고른 변화들을 덩어리로 묶어주기
    ```shell
    git commit -m "커밋 메시지"
    ```
    누적 랭킹으로 줄 세워줬다는 내용의 메시지를 적어줬어요.


6. 커밋을 레포지토리에 적용하기
    ```shell
    git push origin master
    ```
    자, 이제 포크한 레포지토리에 히나타의 커밋을 적용시키는 건 완료됐어요!


7. 오리지널 레포지토리에 적용 위해 풀리퀘 열기

    이 커밋을 오리지널 레포지토리에도 적용하기 위해서는 레포지토리에 access를 가진 선배들이 직접 병합시켜줘야 해요. 선배들에게 오리지널 레포지토리에 커밋 적용을 요청하는 기능이 바로 pull request에요. 포크한 레포지토리 페이지로 들어가면 1commit ahead되어 있다고 뜨네요! 오리지널 레포지토리보다 히나타가 적용한 커밋 하나가 더 적용되어 있다는 의미겠죠? contribute를 눌러 pull request를 open 해줄게요.

### 스가와라 2
히나타의 커밋 요청(pull request)을 받아들여 오리지널 레포지토리에 적용해주고(merge), 새로운 작업을 업로드 하려 해요.

1. 풀리퀘 오리지널 레포지토리에 병합하기


    앗, 알림이 왔네요! 오리지널 레포지토리의 커밋 부분을 열어보니 히나타가 pull request를 보냈네요. 내용을 보니 충돌하는 등의 에러는 없는 것 같아요. 오리지널 레포지토리에 병합해 줄게요.


2. 작업하기
    ```python
    setter_players.sort_values(by='Ranking All',ascending=True)
    ```
    흠, 히나타의 작업물인 랭킹 세우기를 보니, 스가와라도 세터 선수들을 랭킹으로 세워보고 싶어요. 이전에 만든 세터 데이터프레임에서 랭킹 순으로 나열해 볼게요.


3. 커밋에 포함할 변화 고르기
    ```shell
    git add .
    ```
    git이 알아서 바뀐 파일 변화를 골라줄테니 . 으로 전체 선택해줄게요.


4. 고른 변화들을 덩어리로 묶어주기
    ```shell
    git commit -m "커밋 메시지"
    ```
    세터들을 랭킹으로 줄세웠다는 내용의 메시지를 적어줄게요.


5. 커밋을 레포지토리에 적용하기
    ```shell
    git push origin master
    ```
    push를 통해 커밋을 적용시켜주면, 완료!

### 히나타 2
스가와라 선배가 새로 커밋을 올렸다고 해요! 복사본 레포지토리를 업데이트해주고, 로컬 폴더도 업데이트 해줘야겠어요.

1. 오리지널 레포지토리 커밋 받아오기
    포크한 레포지토리에 오니 오리지널 레포지토리보다 1 commit behind인 상태라고 하네요! fetch upstream이라는 버튼을 눌러볼게요. fetch and merge라는 버튼이 있는데, 파일 변화를 받아오고(fetch) 적용시키는(merge) 기능이에요. 자, 이제 오리지널 레포지토리와 동등(even)한 상태가 됐네요.


2. 레포지토리의 변화 로컬 폴더에 적용하기
    ```shell
    git pull origin master
    ```
    포크한 레포지토리에 fetch and merge한 내용을 로컬 작업 폴더에도 적용시켜줄게요. 혹시나 적용을 안 시킨 상태에서 작업한 뒤 커밋 올릴 때의 에러는 상상하기도 싫으니까요!


## 정리
이번 가상 협업 시나리오를 통해 프로젝트 관리자, 권한이 있는 협업자, 권한이 없는 기여자 세명이 어떻게 git을 사용해 협업을 이어나가는지에 대해 배웠습니다. 잘 이해가 가시나요? 단순히 읽어보는데 그치는 것이 아니라 조금씩 변형해서 스스로 실습해보시기 바래요. git에 익숙해지기 위해서는 다양한 상황에서 다양한 명령어와 기능을 써보는 수밖에 없으니까요! git을 실제 사용해야 하는데, 어떤 상황에 어떤 명령어나 기능을 사용해야하는지 헷갈릴 때도 와서 참고하세요. 큰 도움이 될 거에요.